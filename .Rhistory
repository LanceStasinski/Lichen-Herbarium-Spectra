accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
#create variable importance matrix for each class
for(i in 1:length(uniqueNames)){
name = paste(uniqueNames[i], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = 2001)))
}
#start of PLSDA code
for(i in 1:1){
#create data partition: 70% of data for training, 30% for testing
inTrain <- caret::createDataPartition(
y = spec_df[className],
p = .7,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model: 10-fold cross-validation repeated 3 times
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = resampling,
repeats = 3)
#Fit model. Note max iterations set to 10000 to allow model convergence
plsFit <- train(
training[className] ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
#variable importance
vip = varImp(plsFit)
for (j in 1:length(uniqueNames)) {
class.vip = assign(paste0(uniqueNames[j], i), vip$importance$uniqueNames(j))
vip.list[j] = cbind(vip.list[j], class.vip)
}
#accuracy objects for determining n components
a = assign(paste0('a', i), as.matrix(plsFit$results$Accuracy))
a.fit <- cbind(a.fit, get('a'))
#test model using the testing data partition (20% of data)
plsClasses <- predict(plsFit, newdata = testing)
#confusion/classification matrix objects to assess accuracy
cm = confusionMatrix(data = plsClasses, as.factor(testing$Species_ID))
cm.m = assign(paste0("cm", i), as.matrix(cm))
cm.list <- list.append(cm.list, get('cm.m'))
ac <- assign(paste0('acc',i), cm$overall[1])
accuracy <- append(accuracy, get('ac'))
kap = assign(paste0("kap",i), cm$overall[2])
kappa <- append(kappa, get('kap'))
}
}
classify(file = "spectra/lichen_spectra.rds", className = "scientificName", ncomp = 3, resampling = "down")
spec_all = readRDS("spectra/lichen_spectra.rds")
className = "scientificName"
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
spec_df[className]
spec_df[[className]]
classify = function(file, className, ncomp, resampling) {
spec_all = readRDS(file)
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
##################
#Run PLSDA
##################
#create vectors, lists, and matrices to store metrics and variable importance
accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
#create variable importance matrix for each class
for(i in 1:length(uniqueNames)){
name = paste(uniqueNames[i], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = 2001)))
}
#start of PLSDA code
for(i in 1:1){
#create data partition: 70% of data for training, 30% for testing
inTrain <- caret::createDataPartition(
y = spec_df[[className]],
p = .7,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model: 10-fold cross-validation repeated 3 times
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = resampling,
repeats = 3)
#Fit model. Note max iterations set to 10000 to allow model convergence
plsFit <- train(
training[className] ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
#variable importance
vip = varImp(plsFit)
for (j in 1:length(uniqueNames)) {
class.vip = assign(paste0(uniqueNames[j], i), vip$importance$uniqueNames(j))
vip.list[j] = cbind(vip.list[j], class.vip)
}
#accuracy objects for determining n components
a = assign(paste0('a', i), as.matrix(plsFit$results$Accuracy))
a.fit <- cbind(a.fit, get('a'))
#test model using the testing data partition (20% of data)
plsClasses <- predict(plsFit, newdata = testing)
#confusion/classification matrix objects to assess accuracy
cm = confusionMatrix(data = plsClasses, as.factor(testing$Species_ID))
cm.m = assign(paste0("cm", i), as.matrix(cm))
cm.list <- list.append(cm.list, get('cm.m'))
ac <- assign(paste0('acc',i), cm$overall[1])
accuracy <- append(accuracy, get('ac'))
kap = assign(paste0("kap",i), cm$overall[2])
kappa <- append(kappa, get('kap'))
}
}
classify(file = "spectra/lichen_spectra.rds", className = "scientificName", ncomp = 3, resampling = "down")
classify = function(file, className, ncomp, resampling) {
spec_all = readRDS(file)
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
##################
#Run PLSDA
##################
#create vectors, lists, and matrices to store metrics and variable importance
accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
#create variable importance matrix for each class
for(i in 1:length(uniqueNames)){
name = paste(uniqueNames[i], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = 2001)))
}
#start of PLSDA code
for(i in 1:1){
#create data partition: 70% of data for training, 30% for testing
inTrain <- caret::createDataPartition(
y = spec_df[[className]],
p = .7,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model: 10-fold cross-validation repeated 3 times
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = resampling,
repeats = 3)
#Fit model. Note max iterations set to 10000 to allow model convergence
plsFit <- train(
training[[className]] ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
#variable importance
vip = varImp(plsFit)
for (j in 1:length(uniqueNames)) {
class.vip = assign(paste0(uniqueNames[j], i), vip$importance$uniqueNames(j))
vip.list[j] = cbind(vip.list[j], class.vip)
}
#accuracy objects for determining n components
a = assign(paste0('a', i), as.matrix(plsFit$results$Accuracy))
a.fit <- cbind(a.fit, get('a'))
#test model using the testing data partition (20% of data)
plsClasses <- predict(plsFit, newdata = testing)
#confusion/classification matrix objects to assess accuracy
cm = confusionMatrix(data = plsClasses, as.factor(testing$Species_ID))
cm.m = assign(paste0("cm", i), as.matrix(cm))
cm.list <- list.append(cm.list, get('cm.m'))
ac <- assign(paste0('acc',i), cm$overall[1])
accuracy <- append(accuracy, get('ac'))
kap = assign(paste0("kap",i), cm$overall[2])
kappa <- append(kappa, get('kap'))
}
}
classify = function(file, className, ncomp, resampling) {
spec_all = readRDS(file)
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
##################
#Run PLSDA
##################
#create vectors, lists, and matrices to store metrics and variable importance
accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
#create variable importance matrix for each class
for(i in 1:length(uniqueNames)){
name = paste(uniqueNames[i], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = 2001)))
}
#start of PLSDA code
for(i in 1:1){
#create data partition: 70% of data for training, 30% for testing
inTrain <- caret::createDataPartition(
y = spec_df[[className]],
p = .7,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model: 10-fold cross-validation repeated 3 times
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = resampling,
repeats = 3)
#Fit model. Note max iterations set to 10000 to allow model convergence
plsFit <- train(
training[[className]] ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
#variable importance
vip = varImp(plsFit)
for (j in 1:length(uniqueNames)) {
class.vip = assign(paste0(uniqueNames[j], i), vip$importance$uniqueNames(j))
vip.list[j] = cbind(vip.list[j], class.vip)
}
#accuracy objects for determining n components
a = assign(paste0('a', i), as.matrix(plsFit$results$Accuracy))
a.fit <- cbind(a.fit, get('a'))
#test model using the testing data partition (20% of data)
plsClasses <- predict(plsFit, newdata = testing)
#confusion/classification matrix objects to assess accuracy
cm = confusionMatrix(data = plsClasses, as.factor(testing$Species_ID))
cm.m = assign(paste0("cm", i), as.matrix(cm))
cm.list <- list.append(cm.list, get('cm.m'))
ac <- assign(paste0('acc',i), cm$overall[1])
accuracy <- append(accuracy, get('ac'))
kap = assign(paste0("kap",i), cm$overall[2])
kappa <- append(kappa, get('kap'))
}
}
classify(file = "spectra/lichen_spectra.rds", className = "scientificName", ncomp = 3, resampling = "down")
View(classify)
spec_all = readRDS("spectra/lichen_spectra.rds")
className = "scientificName"
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
##################
#Run PLSDA
##################
#create vectors, lists, and matrices to store metrics and variable importance
accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
#create variable importance matrix for each class
for(i in 1:length(uniqueNames)){
name = paste(uniqueNames[i], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = 2001)))
}
spec_all = readRDS("spectra/lichen_spectra.rds")
className = "scientificName"
ncomp = 3
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
##################
#Run PLSDA
##################
#create vectors, lists, and matrices to store metrics and variable importance
accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
#create variable importance matrix for each class
for(i in 1:length(uniqueNames)){
name = paste(uniqueNames[i], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = 2001)))
}
inTrain <- caret::createDataPartition(
y = spec_df[[className]],
p = .7,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
View(training)
resampling = 'down'
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = resampling,
repeats = 3)
plsFit <- train(
training[[className]] ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
spec_all = readRDS("spectra/lichen_spectra.rds")
className = "scientificName"
ncomp = 3
resampling = 'down'
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
##################
#Run PLSDA
##################
#create vectors, lists, and matrices to store metrics and variable importance
accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
#create variable importance matrix for each class
for(i in 1:length(uniqueNames)){
name = paste(uniqueNames[i], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = 2001)))
}
################################################################################
library(spectrolab)
library(caret)
library(dplyr)
library(mlbench)
library(corrplot)
library(matrixStats)
library(naniar)
library(rlist)
spec_all = readRDS("spectra/lichen_spectra.rds")
className = "scientificName"
ncomp = 3
resampling = 'down'
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
##################
#Run PLSDA
##################
#create vectors, lists, and matrices to store metrics and variable importance
accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
#create variable importance matrix for each class
for(i in 1:length(uniqueNames)){
name = paste(uniqueNames[i], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = 2001)))
}
inTrain <- caret::createDataPartition(
y = spec_df[[className]],
p = .7,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
View(training)
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = resampling,
repeats = 3)
#Fit model. Note max iterations set to 100000 to allow model convergence
plsFit <- train(
scientificName ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
c = colnames(training) == className
c
plsFit <- train(
colnames(training) == className ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
plsFit <- train(
className ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
c = as.name(className)
c
className
plsFit <- train(
as.name(className) ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
plsFit <- train(
c ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
str(c)
plsFit <- train(
scientificName ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
plsFit <- train(
training[[className]] ~ .,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
training[[className]]
plsFit <- train(
training[,897] ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
training[,897]
plsFit <- train(
as.factor(training[,897]) ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
traingin[[className]]
training[[className]]
plsFit <- train(
training,
trainging[[className]],
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
plsFit <- train(
training,
training[[className]],
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
waarnings()
warnings()
plsFit <- train(
training,
training[[className]],
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
