t.resamp = resampled[, 400:2400]
#remove any unlabeled white references
noWR = t.resamp[!rowSums(t.resamp > 1),]
return(noWR)
}
################################################################################
#read in and clean spectra
################################################################################
spec.dirs = list.dirs(path = "./spectra")
spec.dirs = spec.dirs[-1]
spec.dirs2 = spec.dirs[-24] #peltigera elisabethae has two sets of spectra:
#1 with 1024 bands and another with 996 bands. These spectra will be handled
#separately from the rest
spec_list = list()
for (i in 1:length(spec.dirs2)) {
#read in spectra. Exclude bad and white reference scans
raw = read_spectra(path = spec.dirs2[i], format = "sig",
exclude_if_matches = c("BAD", "WR"))
#match sensors, trim and resample spectra
clean_spec = clean_spectra(raw)
#add spectra to list of spectra
spec = assign(paste0("spec", i), clean_spec)
spec_list = list.append(spec_list, get("spec"))
}
#combine spectra into single spectra object
spec_all = Reduce(spectrolab::combine, spec_list)
#handle the peltigera spectra
spec.p = read_spectra(path = spec.dirs[24], format = "sig",
exclude_if_matches = c("BAD", "WR"))
spec.p.1 = spec.p[[1]]
spec.p.2 = spec.p[[2]]
spec.p.1.1 = clean_spectra(spec.p.1)
spec.p.2.1 = spec.p.2[, bands(spec.p.2, 392, 2415)]
spec.p.2.2 = resample(spec.p.2.1, seq(392,2415, 1))
spec.p.2.3 = spec.p.2.2[, 400:2400]
#add peltigera spectra to full spectra
spec_all = Reduce(spectrolab::combine, list(spec_all, spec.p.1.1, spec.p.2.3))
#smooth
spec_all = smooth(spec_all)
raw1 = read_spectra(path = spec.dirs2[5], format = "sig",
exclude_if_matches = c("BAD", "WR"))
length(raw1)
ncol(as.matrix(raw1))
raw2 = read_spectra(path = spec.dirs2[8], format = "sig",
exclude_if_matches = c("BAD", "WR"))
ncol(as.matrix(raw2))
e = as.matrix(raw2)
View(e)
x = match_sensors(raw2, splice_at = c(990, 1900),
interpolate_wvl = c(5,1))
x
library(spectrolab)
library(rlist)
################################################################################
#clean spectra function
################################################################################
clean_spectra = function(spectra) {
#match sensor overlap if overlapped regions occur
if (ncol(as.matrix(spectra)) == 1024) {
matched = match_sensors(spectra, splice_at = c(990, 1900),
interpolate_wvl = c(5,1))
#Resample to 1nm resolution to make interpretation easier and trim to 400:2400nm
trimmed = matched[, bands(matched, 392, 2415)]
resampled = resample(trimmed, seq(392,2415, 1))
t.resamp = resampled[, 400:2400]
} else {
trimmed = spectra[, bands(spectra, 392, 2415)]
resampled = resample(trimmed, seq(392,2415, 1))
t.resamp = resampled[, 400:2400]
}
#remove any unlabeled white references
noWR = t.resamp[!rowSums(t.resamp > 1),]
return(noWR)
}
spec.dirs = list.dirs(path = "./spectra")
spec.dirs = spec.dirs[-1]
spec.dirs2 = spec.dirs[-24] #peltigera elisabethae has two sets of spectra:
#1 with 1024 bands and another with 996 bands. These spectra will be handled
#separately from the rest
spec_list = list()
for (i in 1:length(spec.dirs2)) {
#read in spectra. Exclude bad and white reference scans
raw = read_spectra(path = spec.dirs2[i], format = "sig",
exclude_if_matches = c("BAD", "WR"))
#match sensors, trim and resample spectra
clean_spec = clean_spectra(raw)
#add spectra to list of spectra
spec = assign(paste0("spec", i), clean_spec)
spec_list = list.append(spec_list, get("spec"))
}
#combine spectra into single spectra object
spec_all = Reduce(spectrolab::combine, spec_list)
length(unique(names(spec_all)))
spec.p = read_spectra(path = spec.dirs[24], format = "sig",
exclude_if_matches = c("BAD", "WR"))
spec.p.1 = spec.p[[1]]
spec.p.2 = spec.p[[2]]
spec.p.1.1 = clean_spectra(spec.p.1)
spec.p.2.1 = spec.p.2[, bands(spec.p.2, 392, 2415)]
spec.p.2.2 = resample(spec.p.2.1, seq(392,2415, 1))
spec.p.2.3 = spec.p.2.2[, 400:2400]
#add peltigera spectra to full spectra
spec_all = Reduce(spectrolab::combine, list(spec_all, spec.p.1.1, spec.p.2.3))
#smooth
spec_all = smooth(spec_all)
length(unique(names(spec_all)))
saveRDS(spec_all, "spectra/spec_all.rds")
library(spectrolab)
library(rlist)
library(dplyr)
spec_all = readRDS("spectra/spec_all.rds")
data = read.csv("metadata/metadata_joined.csv", stringsAsFactors = F)
################################################################################
#match spectra and meta data names
################################################################################
#add file names to entries with missing file names
broken = data[data$File.Name == "", ]
broken$File.Name = paste(broken$X, broken$year, sep = ".")
data = data[!data$File.Name == "",]
data = rbind(data, broken)
#clean meta data
data = data[!data$Quality == "BAD",]
data = data[!data$Quality == "Not Scanned, bad",]
data$name = paste(data$X, data$year, sep = ".")
rownames(data) = data$name
#clean up spectra names
m = as.matrix(spec_all)
rownames(m) = gsub(".sig", "", rownames(m))
names(spec_all) = rownames(m)
spec_names = as.data.frame(rownames(m))
colnames(spec_names) = "spectra_ID"
#match data and scan names
idx2 = sapply(rownames(data), grep, spec_names$spectra_ID)
#remove data entries that do not have associated spectra
no_spectra = c("654463.1974", "721604.1980", "802685.1988", "815554.1991",
"22571.1892", "772360.1971", "934442.1993", "691863.1963",
"941507.1998", "21569.NA", "21435.1897", "673814.1974",
"15239.1899", "871614.2000", "14293.1899")
data = data[!rownames(data) %in% no_spectra,]
#match names again
idx2 = sapply(rownames(data), grep, spec_names$spectra_ID)
idx1 <- sapply(seq_along(idx2), function(i) rep(i, length(idx2[[i]])))
new_data = cbind(data[unlist(idx1),,drop=F], spec_names[unlist(idx2),,drop=F])
#bring to excell to modify rownames to match spectra names
#write.csv(new_data, "metadata/meta_full.csv")
################################################################################
#Now remove repeated names in scan_names, then remove any names in the metadata
#that are not in the spectra names
################################################################################
data = read.csv("metadata/meta_full.csv", stringsAsFactors = F)
rownames(data) = data[,1]
data = data[,-c(1,2)]
#remove duplicate spectra names and spectra without metadata
spec_names_no_dup = spec_names %>% distinct()
remove.spec = base::setdiff(spec_names_no_dup$spectra_ID, rownames(data))
spec_names_2 = spec_names_no_dup[!spec_names_no_dup$spectra_ID %in% remove.spec,]
#remove metadata without spectra
remove.data = base::setdiff(rownames(data), spec_names_no_dup$spectra_ID)
data = data[!rownames(data) %in% remove.data, ]
#remove duplicate spectra and spectra without metadata
spec_m = as.matrix(spec_all)
spec_df = as.data.frame(spec_m)
spec_df = spec_df %>% distinct()
rownames(spec_df) = gsub("X", "", rownames(spec_df))
spec_new = as_spectra(spec_df)
remove_spectra = base::setdiff(names(spec_new), spec_names_2)
spec_new = spec_new[!names(spec_new) %in% remove_spectra, ]
#remove metadata that somehow is still different than spectra
remove_meta = base::setdiff(rownames(data), names(spec_new))
data = data[!rownames(data) %in% remove_meta, ]
#set metadata in same order as spectra
data = data[names(spec_new),,drop = F]
#Finally, add the metadata
meta(spec_new) = data
saveRDS(spec_new, "spectra/lichen_spectra.rds")
#fix some typing errors in the metadata and resave
spec_all = readRDS("spectra/lichen_spectra.rds")
meta(spec_all)$Morphology = gsub("Foliose", "foliose", meta(spec_all)$Morphology)
meta(spec_all)$scientificName = gsub(" ","_", meta(spec_all)$scientificName)
saveRDS(spec_all, "spectra/lichen_spectra.rds")
#vector normalize
vn = normalize(spec_all)
saveRDS(vn, "spectra/lichen_spectra_vn.rds")
length(unique(names(spec_all)))
classify = function(file, className, ncomp, resampling, n_iteration) {
#require packages
require(spectrolab)
require(caret)
require(dplyr)
require(rlist)
require(matrixStats)
require(mlbench)
#load spectra and convert to matrix and dataframe
spec_all = readRDS(file)
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
##################
#Run PLSDA
##################
#create vectors, lists, and matrices to store metrics and variable importance
accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
results = list()
#create variable importance matrix for each class
for(j in 1:length(uniqueNames)){
name = paste(uniqueNames[j], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = ncol(spec_mat))))
}
#start of PLSDA code
for(i in 1:n_iteration){
#create data partition: 70% of data for training, 30% for testing
inTrain <- caret::createDataPartition(
y = spec_df[[className]],
p = .7,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model: 10-fold cross-validation repeated 3 times
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = resampling,
repeats = 3)
#Fit model. Note max iterations set to 100000 to allow model convergence
plsFit <- train(
as.formula(paste(className, "~ .")),
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
#variable importance
vip = varImp(plsFit)
for (k in 1:length(uniqueNames)) {
class.vip = assign(paste0(uniqueNames[k], i), vip$importance[uniqueNames[k]])
vip.list[[k]] = cbind(vip.list[[k]], get('class.vip'))
}
#accuracy objects for determining n components
a = assign(paste0('a', i), as.matrix(plsFit$results$Accuracy))
a.fit <- cbind(a.fit, get('a'))
#test model using the testing data partition (20% of data)
plsClasses <- predict(plsFit, newdata = testing)
#confusion/classification matrix objects to assess accuracy
cm = confusionMatrix(data = plsClasses, as.factor(testing[[className]]))
cm.m = assign(paste0("cm", i), as.matrix(cm))
cm.list <- list.append(cm.list, get('cm.m'))
ac <- assign(paste0('acc',i), cm$overall[1])
accuracy <- append(accuracy, get('ac'))
kap = assign(paste0("kap",i), cm$overall[2])
kappa <- append(kappa, get('kap'))
}
results = list.append(results, vip.list)
results = list.append(results, a.fit)
results = list.append(results, cm.list)
results = list.append(results, accuracy)
results = list.append(results, kappa)
return(results)
}
saveRDS(classify, "functions/plsda.rds")
classify = readRDS("functions/plsda.rds")
pls = classify(file = "spectra/lichen_spectra.rds",
className = "scientificName",
ncomp = 3,
resampling = 'down',
n_iteration = 3)
accuracy = pls[[4]]
mean(accuracy)
sd(accuracy)
kappa = pls[[5]]
mean(kappa)
sd(kappa)
#proportions
cm.list = pls[[3]]
cm.avg = Reduce('+', cm.list)/100
cm.avg = t(cm.avg)
cm.total = cm.avg/rowSums(cm.avg)
cols = colorRampPalette(c('#f5f5f5', '#fe9929'))
par(mfrow = c(1,1))
corrplot::corrplot(as.matrix(cm.total),
method = 'square',
tl.col = 'black',
cl.lim = c(0,1),
na.label = 'square',
na.label.col = 'white',
col = cols(10))
cols = colorRampPalette(c('white', '#fe9929'))
par(mfrow = c(1,1))
corrplot::corrplot(as.matrix(cm.total),
method = 'square',
tl.col = 'black',
cl.lim = c(0,1),
na.label = 'square',
na.label.col = 'white',
col = cols(10))
vip.list = pls[[1]]
v30 = vip.list[[30]][,-1]
v30.t = t(v30)
View(v30.t)
colnames(v30.t) = as.numeric(colnames(v30.t))
v30 = vip.list[[30]][,-1]
v30.t = t(v30)
str(colnames(v30.t))
colnames(v30.t) = as.integer(colnames(v30.t))
View(v30.t)
v30 = vip.list[[30]][,-1]
v30.t = t(v30)
v30.s = as_spectra(v30.t)
colnames(v30.t) = gsub("'", "", colnames(v30.t))
View(v30.t)
colnames(v30.t) = gsub("`", "", colnames(v30.t))
View(v30.t)
v30.s = as_spectra(v30.t)
plot(v30.s)
vip_to_spec = function(x){
t.vip = t(x[,-1])
colnames(t.vip) <- gsub("`", "", colnames(t.vip))
s.vip = as_spectra(t.vip)
plot(mean(s.vip), lwd = 1.5, lty = 1, ylim = c(0, 100),
ylab = "Variable Importance", xlab = NA, cex.lab = 1.5)
plot_quantile(s.vip, total_prob = 0.95, col = rgb(0, 0.69, 0.965, 0.25),
border = FALSE, add = TRUE)
}
vip_to_spec(v30)
length(vip.list)
vip.list = pls[[1]]
par(mfrow = c(5,6))
for (j in 1:length(vip.list)) {
vip_to_spec(vip.list[[j]])
}
vip_to_spec = function(x){
t.vip = t(x[,-1])
colnames(t.vip) <- gsub("`", "", colnames(t.vip))
s.vip = as_spectra(t.vip)
plot(mean(s.vip), lwd = 1.5, lty = 1, ylim = c(0, 100),
ylab = "Variable Importance", xlab = "Wavelength (nm)", cex.lab = 1)
plot_quantile(s.vip, total_prob = 0.95, col = rgb(0, 0, 0, 0.25),
border = FALSE, add = TRUE)
}
vip.list = pls[[1]]
par(mfrow = c(5,6))
for (j in 1:length(vip.list)) {
vip_to_spec(vip.list[[j]])
}
spectra = readRDS('spectra/lichen_spectra.rds')
m = as.matrix(spectra)
View(m)
library(spectrolab)
m = as.matrix(spectra)
m
View(m)
################################################################################
library(corrplot)
library(matrixStats)
library(naniar)
library(spectrolab)
################################################################################
#run plsda
################################################################################
classify = readRDS("functions/plsda.rds")
pls = classify(file = "spectra/lichen_spectra.rds",
className = "scientificName",
ncomp = 60,
resampling = 'down',
n_iteration = 100)
install.packages('e1071')
classify = readRDS("functions/plsda.rds")
pls = classify(file = "spectra/lichen_spectra.rds",
className = "scientificName",
ncomp = 60,
resampling = 'down',
n_iteration = 100)
warnings()
library(corrplot)
library(matrixStats)
library(naniar)
library(spectrolab)
################################################################################
#run plsda
################################################################################
classify = readRDS("functions/plsda.rds")
pls = classify(file = "spectra/lichen_spectra.rds",
className = "scientificName",
ncomp = 50,
resampling = 'down',
n_iteration = 100)
pls = classify(file = "spectra/lichen_spectra.rds",
className = "scientificName",
ncomp = 50,
resampling = 'down',
n_iteration = 100)
accuracy = pls[[4]]
mean(accuracy)
sd(accuracy)
a.fit = pls[[2]]
a.total = a.fit[,-1]
a.avg = as.matrix(rowMeans(a.total))
a.sd = as.matrix(rowSds(a.total))
a.lower = a.avg - a.sd
a.higher = a.avg + a.sd
#Graph to visually choose optimal number of components
x = 1:3
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,60), main = 'Accuracy for Species_ID',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
x = 1:50
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,50), main = 'Accuracy for Species_ID',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
max(a.avg)
a.avg
cm.list = pls[[3]]
cm.avg = Reduce('+', cm.list)/100
cm.avg = t(cm.avg)
cm.total = cm.avg/rowSums(cm.avg)
#standard deviations
f1 <- function(lst){
n <- length(lst);
rc <- dim(lst[[1]]);
ar1 <- array(unlist(lst), c(rc, n));
round(apply(ar1, c(1, 2), sd), 2);
}
cm.sd = f1(cm.list)
cm.sd = t(cm.sd)
cm.sd = cm.sd/rowSums(cm.avg)
rownames(cm.sd) = rownames(as.matrix(cm.list[[1]]))
colnames(cm.sd) = colnames(as.matrix(cm.list[[1]]))
cm.total = as.data.frame(cm.total)
cm.total = cm.total %>% replace_with_na_all(condition = ~.x == 0)
cm.total = as.matrix(cm.total)
rownames(cm.total) = rownames(as.matrix(cm.list[[1]]))
colnames(cm.total) = colnames(as.matrix(cm.list[[1]]))
cols = colorRampPalette(c('white', '#fe9929'))
par(mfrow = c(1,1))
corrplot::corrplot(as.matrix(cm.total),
method = 'square',
tl.col = 'black',
cl.lim = c(0,1),
na.label = 'square',
na.label.col = 'white',
col = cols(10))
gc()
library(corrplot)
library(matrixStats)
library(naniar)
library(spectrolab)
################################################################################
#run plsda
################################################################################
classify = readRDS("functions/plsda.rds")
pls = classify(file = "spectra/lichen_spectra.rds",
className = "scientificName",
ncomp = 26,
resampling = 'up',
n_iteration = 100)
saveRDS(pls, 'models/species.rds')
cm.list = pls[[3]]
cm.avg = Reduce('+', cm.list)/100
cm.avg = t(cm.avg)
cm.total = cm.avg/rowSums(cm.avg)
#standard deviations
f1 <- function(lst){
n <- length(lst);
rc <- dim(lst[[1]]);
ar1 <- array(unlist(lst), c(rc, n));
round(apply(ar1, c(1, 2), sd), 2);
}
cm.sd = f1(cm.list)
cm.sd = t(cm.sd)
cm.sd = cm.sd/rowSums(cm.avg)
rownames(cm.sd) = rownames(as.matrix(cm.list[[1]]))
colnames(cm.sd) = colnames(as.matrix(cm.list[[1]]))
cm.total = as.data.frame(cm.total)
cm.total = cm.total %>% replace_with_na_all(condition = ~.x == 0)
cm.total = as.matrix(cm.total)
rownames(cm.total) = rownames(as.matrix(cm.list[[1]]))
colnames(cm.total) = colnames(as.matrix(cm.list[[1]]))
cols = colorRampPalette(c('white', '#fe9929'))
par(mfrow = c(1,1))
corrplot::corrplot(as.matrix(cm.total),
method = 'square',
tl.col = 'black',
cl.lim = c(0,1),
na.label = 'square',
na.label.col = 'white',
col = cols(10))
accuracy = pls[[4]]
mean(accuracy)
sd(accuracy)
kappa = pls[[5]]
mean(kappa)
sd(kappa)
