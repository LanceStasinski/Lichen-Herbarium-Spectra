xlab = 'Wavelength (nm)',
type = 'l')
dev.off()
#setup spectral data
spectra = readRDS('spectra/lichen_spectra.rds')
nrow(spectra)
56-38
library(spectrolab)
?spectrolab::guess_splice_at()
?match_sensors
library(corrplot)
library(matrixStats)
library(naniar)
library(spectrolab)
################################################################################
#run plsda
################################################################################
spectra = readRDS('spectra/lichen_spectra.rds')
classify = readRDS("functions/plsda.rds")
head(meta(spectra))
unique(meta(spectra)$Morphology)
spectra = spectra[meta(spectra)$Morphology != 'fruticose',]
pls = classify(spectra = spectra,
className = "Morphology",
ncomp = 60,
resampling = 'down',
n_iteration = 100,
include_age = F)
saveRDS(pls, 'models/morphology.rds')
spec_all = as.data.frame(spectra)
u = unique(spec_all[['Morphology']])
u
spec_all = spectra
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
className = 'Morphology'
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
#create vectors, lists, and matrices to store metrics and variable importance
accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
results = list()
model.list = list()
a.fit = matrix(nrow = 2)
ncomp = 2
for(j in 1:length(uniqueNames)){
name = paste(uniqueNames[j], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = ncol(spec_df)-1)))
}
n_iteration = 1
inTrain <- caret::createDataPartition(
y = spec_df[[className]],
p = .7,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model: 10-fold cross-validation repeated 3 times
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = resampling,
repeats = 3)
#Fit model. Note max iterations set to 100000 to allow model convergence
plsFit <- train(
as.formula(paste(className, "~ .")),
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
resampling = 'down'
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = resampling,
repeats = 3)
plsFit <- train(
as.formula(paste(className, "~ .")),
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
#variable importance
vip = varImp(plsFit)
vip
uniqueNames
vip$importance
vip$importance[uniqueName[1]]
vip$importance[uniqueNames[1]]
head(vip$importance)
if (length(uniqueNames) > 2) {
vip = varImp(plsFit)
for (k in 1:length(uniqueNames)) {
class.vip = assign(paste0(uniqueNames[k], i), vip$importance[uniqueNames[k]])
vip.list[[k]] = cbind(vip.list[[k]], get('class.vip'))
}
}
results = list.append(results, vip.list)
classify = function(spectra, className, ncomp, resampling, n_iteration, include_age) {
#require packages
require(spectrolab)
require(caret)
require(dplyr)
require(rlist)
require(matrixStats)
require(mlbench)
#load spectra and convert to matrix and dataframe
spec_all = spectra
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relevant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df[className])
colnames(spec_df)[colnames(spec_df) == className] <- className
uniqueNames = unique(spec_all.df[[className]])
if (include_age == TRUE) {
spec_df$age = spec_all.df$age
}
##################
#Run PLSDA
##################
#create vectors, lists, and matrices to store metrics and variable importance
accuracy = c()
kappa = c()
a.fit = matrix(nrow = ncomp)
cm.list = list()
vip.list = list()
results = list()
model.list = list()
#create variable importance matrix for each class
for(j in 1:length(uniqueNames)){
name = paste(uniqueNames[j], "vip", sep = ".")
vip.list = list.append(vip.list, assign(name, matrix(nrow = ncol(spec_df)-1)))
}
#start of PLSDA code
for(i in 1:n_iteration){
#create data partition: 70% of data for training, 30% for testing
inTrain <- caret::createDataPartition(
y = spec_df[[className]],
p = .7,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model: 10-fold cross-validation repeated 3 times
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = resampling,
repeats = 3)
#Fit model. Note max iterations set to 100000 to allow model convergence
plsFit <- train(
as.formula(paste(className, "~ .")),
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
#variable importance
if (length(uniqueNames) > 2) {
vip = varImp(plsFit)
for (k in 1:length(uniqueNames)) {
class.vip = assign(paste0(uniqueNames[k], i), vip$importance[uniqueNames[k]])
vip.list[[k]] = cbind(vip.list[[k]], get('class.vip'))
}
}
#accuracy objects for determining n components
a = assign(paste0('a', i), as.matrix(plsFit$results$Accuracy))
a.fit <- cbind(a.fit, get('a'))
#test model using the testing data partition (20% of data)
plsClasses <- predict(plsFit, newdata = testing)
#confusion/classification matrix objects to assess accuracy
cm = confusionMatrix(data = plsClasses, as.factor(testing[[className]]))
cm.m = assign(paste0("cm", i), as.matrix(cm))
cm.list <- list.append(cm.list, get('cm.m'))
ac <- assign(paste0('acc',i), cm$overall[1])
accuracy <- append(accuracy, get('ac'))
kap = assign(paste0("kap",i), cm$overall[2])
kappa <- append(kappa, get('kap'))
}
results = list.append(results, vip.list)
results = list.append(results, a.fit)
results = list.append(results, cm.list)
results = list.append(results, accuracy)
results = list.append(results, kappa)
return(results)
}
saveRDS(classify, "functions/plsda.rds")
spectra = readRDS('spectra/lichen_spectra.rds')
spectra = spectra[meta(spectra)$Morphology != 'fruticose',]
classify = readRDS("functions/plsda.rds")
pls = classify(spectra = spectra,
className = "Morphology",
ncomp = 60,
resampling = 'down',
n_iteration = 100,
include_age = F)
saveRDS(pls, 'models/morphology.rds')
accuracy = pls[[4]]
mean(accuracy)
sd(accuracy)
kappa = pls[[5]]
mean(kappa)
sd(kappa)
################################################################################
a.fit = pls[[2]]
a.total = a.fit[,-1]
a.avg = as.matrix(rowMeans(a.total))
a.sd = as.matrix(rowSds(a.total))
a.lower = a.avg - a.sd
a.higher = a.avg + a.sd
#Graph to visually choose optimal number of components
x = 1:60
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,60), main = 'Accuracy for Species_ID',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
which.max(a.avg)
spectra = readRDS('spectra/lichen_spectra.rds')
spectra = spectra[meta(spectra)$Morphology != 'fruticose',]
classify = readRDS("functions/plsda.rds")
pls = classify(spectra = spectra,
className = "Morphology",
ncomp = 23,
resampling = 'up',
n_iteration = 100,
include_age = F)
saveRDS(pls, 'models/morphology.rds')
accuracy = pls[[4]]
mean(accuracy)
sd(accuracy)
t.test2 <- function(m1,m2,s1,s2,n1,n2,m0=0,equal.variance=FALSE)
{
if( equal.variance==FALSE )
{
se <- sqrt( (s1^2/n1) + (s2^2/n2) )
# welch-satterthwaite df
df <- ( (s1^2/n1 + s2^2/n2)^2 )/( (s1^2/n1)^2/(n1-1) + (s2^2/n2)^2/(n2-1) )
} else
{
# pooled standard deviation, scaled by the sample sizes
se <- sqrt( (1/n1 + 1/n2) * ((n1-1)*s1^2 + (n2-1)*s2^2)/(n1+n2-2) )
df <- n1+n2-2
}
t <- (m1-m2-m0)/se
dat <- c(m1-m2, se, t, 2*pt(-abs(t),df))
names(dat) <- c("Difference of means", "Std Error", "t", "p-value")
return(dat)
}
t.test2(m1 = 76.94587, m2 = 80.49003, s1 = 1.97579, s2 = 1.91673, n1 = 100, n2 = 100)
t.test2(m1 = 94.50704, m2 = 94.43662, s1 = 1.052847, s2 = 1.252978, n1 = 100, n2 = 100)
t.test2(m1 = 89.0056, m2 = 89.493, s1 = 1.28294, s2 = 1.380609, n1 = 100, n2 = 100)
t.test2(m1 = 82.45833, m2 = 83.86111, s1 = 2.141263, s2 = 2.012594, n1 = 100, n2 = 100)
library(corrplot)
library(matrixStats)
library(naniar)
library(spectrolab)
pls = readRDS('models/species.rds')
################################################################################
a.fit = pls[[2]]
a.total = a.fit[,-1]
a.avg = as.matrix(rowMeans(a.total))
a.sd = as.matrix(rowSds(a.total))
a.lower = a.avg - a.sd
a.higher = a.avg + a.sd
#Graph to visually choose optimal number of components
x = 1:60
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,60), main = 'Accuracy for Species_ID',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
length(a.avg)
a.fit = pls[[2]]
a.total = a.fit[,-1]
a.avg = as.matrix(rowMeans(a.total))
a.sd = as.matrix(rowSds(a.total))
a.lower = a.avg - a.sd
a.higher = a.avg + a.sd
#Graph to visually choose optimal number of components
x = 1:26
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,60), main = 'Accuracy for Species_ID',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
x = 1:26
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,26), main = 'Accuracy for Species_ID',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
x = 1:26
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,26), main = 'Accuracy for Species_ID',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
x = 1:26
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,26), main = 'Accuracy for Species_ID',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
pls = readRDS('models/family.rds')
################################################################################
#Assess accuracy and kappa
################################################################################
accuracy = pls[[4]]
mean(accuracy)
sd(accuracy)
kappa = pls[[5]]
mean(kappa)
sd(kappa)
################################################################################
#Accuracy values for choosing the optimal number of components to use
################################################################################
a.fit = pls[[2]]
a.total = a.fit[,-1]
a.avg = as.matrix(rowMeans(a.total))
a.sd = as.matrix(rowSds(a.total))
a.lower = a.avg - a.sd
a.higher = a.avg + a.sd
#Graph to visually choose optimal number of components
x = seq(1: length(a.avg))
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,length(a.avg)), main = 'Accuracy for Family',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
pls = readRDS('models/order.rds')
################################################################################
#Assess accuracy and kappa
################################################################################
accuracy = pls[[4]]
mean(accuracy)
sd(accuracy)
kappa = pls[[5]]
mean(kappa)
sd(kappa)
################################################################################
#Accuracy values for choosing the optimal number of components to use
################################################################################
a.fit = pls[[2]]
a.total = a.fit[,-1]
a.avg = as.matrix(rowMeans(a.total))
a.sd = as.matrix(rowSds(a.total))
a.lower = a.avg - a.sd
a.higher = a.avg + a.sd
#Graph to visually choose optimal number of components
x = seq(1: length(a.avg))
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,length(a.avg)), main = 'Accuracy for Order',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
pls = readRDS('models/class.rds')
################################################################################
#Assess accuracy and kappa
################################################################################
accuracy = pls[[4]]
mean(accuracy)
sd(accuracy)
kappa = pls[[5]]
mean(kappa)
sd(kappa)
################################################################################
#Accuracy values for choosing the optimal number of components to use
################################################################################
a.fit = pls[[2]]
a.total = a.fit[,-1]
a.avg = as.matrix(rowMeans(a.total))
a.sd = as.matrix(rowSds(a.total))
a.lower = a.avg - a.sd
a.higher = a.avg + a.sd
#Graph to visually choose optimal number of components
x = seq(1: length(a.avg))
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,length(a.avg)), main = 'Accuracy for Class',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = which.max(a.avg), col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
library(corrplot)
library(matrixStats)
library(naniar)
library(spectrolab)
################################################################################
#run plsda
################################################################################
spectra = readRDS('spectra/lichen_spectra.rds')
classify = readRDS("functions/plsda.rds")
pls = classify(spectra = spectra,
className = "class",
ncomp = 4,
resampling = 'up',
n_iteration = 50,
include_age = F)
pls = classify(spectra = spectra,
className = "Class",
ncomp = 4,
resampling = 'up',
n_iteration = 50,
include_age = F)
pls = readRDS('models/class.rds')
################################################################################
#Assess accuracy and kappa
################################################################################
accuracy = pls[[4]]
hist(accuracy)
pls = readRDS('models/order.rds')
################################################################################
#Assess accuracy and kappa
################################################################################
accuracy = pls[[4]]
hist(accuracy)
pls = readRDS('models/family.rds')
################################################################################
#Assess accuracy and kappa
################################################################################
accuracy = pls[[4]]
hist(accuracy)
pls = readRDS('models/species.rds')
################################################################################
#Assess accuracy and kappa
################################################################################
accuracy = pls[[4]]
hist(accuracy)
species = readRDS('models/species.rds')[[4]]
species_age = readRDS('models/species_age.rds')[[4]]
hist(species_age)
hist(sqrt(species_age))
hist(log(species_age))
hist(species_age)
?t.test
t.tes(species, species_age)
t.test(species, species_age)
t.test(sqrt(species), sqrt(species_age))
family = readRDS('models/family.rds')[[4]]
family_age = readRDS('models/family_age.rds')[[4]]
t.test(family, family_age)
t.test(sqrt(family), sqrt(family_age))
order = readRDS('models/order.rds')[[4]]
order_age = readRDS('models/order_age.rds')[[4]]
t.test(order, order_age)
t.test(sqrt(order), sqrt(order_age))
class = readRDS('models/class.rds')[[4]]
class_age = readRDS('models/class_age.rds')[[4]]
t.test(class, class_age)
t.test(sqrt(class), sqrt(class_age))
hist(class_age)
hist(class)
hist(sqrt(class))
hist(sqrt(class_age))
hist(sqrt(order))
hist(sqrt(order_age))
hist(order)
hist(family)
hist(sqrt(family_age))
hist(sqrt(family))
hist(species)
hist(sqrt(species))
hist(species_age)
hist(sqrt(species_age))
t.test(sqrt(species), sqrt(species_age))
t.test(family, family_age)
t.test(order, order_age)
t.test(class, class_age)
